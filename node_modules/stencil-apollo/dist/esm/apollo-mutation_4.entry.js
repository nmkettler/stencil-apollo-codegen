import { r as registerInstance, c as createEvent, g as getElement, h } from './core-eaceb4a9.js';
import { A as ApolloProviderConsumer } from './apollo-client-state-7be4f0b5.js';

const ApolloMutationComponent = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.readyEventEmitter = createEvent(this, "ready", 7);
    }
    componentWillLoad() {
        this.passMutation();
    }
    onPropsChange() {
        this.passMutation();
    }
    async passMutation() {
        if (this.client) {
            this.mutationFn = args => this.client.mutate(Object.assign({ mutation: this.mutation, variables: this.variables }, this.options, args));
            this.readyEventEmitter.emit(this.mutationFn);
        }
        else {
            throw new Error('You should wrap your parent component with apollo-provider custom element or ApolloProvider functional component');
        }
    }
    render() {
        return this.renderer && this.renderer(this.mutationFn);
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "client": ["onPropsChange"],
        "mutation": ["onPropsChange"],
        "variables": ["onPropsChange"],
        "renderer": ["onPropsChange"],
        "options": ["onPropsChange"]
    }; }
};
ApolloProviderConsumer.injectProps(ApolloMutationComponent, ['client']);

const Declarations = "DECLARATIONS";

const Provider = ApolloProviderConsumer.Provider;
const ApolloProviderComponent = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.declarations = Declarations;
    }
    render() {
        return (h(Provider, { state: { client: this.client } }, h("slot", null)));
    }
};

const ApolloQueryComponent = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.readyEventEmitter = createEvent(this, "ready", 7);
        this.resultEventEmitter = createEvent(this, "result", 7);
    }
    componentWillLoad() {
        this.startSubscription();
    }
    onPropsChange() {
        this.stopSubscription();
        this.startSubscription();
    }
    componentDidUnload() {
        this.stopSubscription();
    }
    getResult() {
        return {
            data: this.originalResult && this.originalResult.data,
            loading: this.originalResult ? this.originalResult.loading : true,
            error: {
                graphQLErrors: this.originalResult && this.originalResult.errors,
                networkError: undefined,
                message: this.originalResult && this.originalResult.errors && this.originalResult.errors[0] && this.originalResult.errors[0].message,
                name: this.originalResult && this.originalResult.errors && this.originalResult.errors[0] && this.originalResult.errors[0].name,
                extraInfo: this.originalResult && this.originalResult.errors && this.originalResult.errors[0] && this.originalResult.errors[0].originalError,
            },
            variables: this.variables,
            networkStatus: this.originalResult && this.originalResult.networkStatus,
            refetch: this.observable && this.observable.refetch.bind(this.observable),
            fetchMore: this.observable && this.observable.fetchMore.bind(this.observable),
            startPolling: this.observable && this.observable.startPolling.bind(this.observable),
            stopPolling: this.observable && this.observable.stopPolling.bind(this.observable),
            subscribeToMore: this.observable && this.observable.subscribeToMore.bind(this.observable),
            updateQuery: this.observable && this.observable.updateQuery.bind(this.observable),
            client: this.client,
        };
    }
    startSubscription() {
        if (this.client) {
            const observable = this.client.watchQuery(Object.assign({ query: this.query, variables: this.variables }, this.options));
            this._subscription = observable.subscribe(originalResult => {
                this.originalResult = originalResult;
                this.resultEventEmitter.emit(this.getResult());
            }, error => {
                this.error = error;
                this.resultEventEmitter.emit(this.getResult());
            });
            this.readyEventEmitter.emit(this.getResult());
        }
        else {
            throw new Error('You should wrap your parent component with apollo-provider custom element or ApolloProvider functional component');
        }
    }
    stopSubscription() {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    }
    render() {
        return this.renderer && this.renderer(this.getResult());
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "client": ["onPropsChange"],
        "query": ["onPropsChange"],
        "variables": ["onPropsChange"],
        "renderer": ["onPropsChange"],
        "options": ["onPropsChange"]
    }; }
};
ApolloProviderConsumer.injectProps(ApolloQueryComponent, ['client']);

const ApolloSubscriptionComponent = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.readyEventEmitter = createEvent(this, "ready", 7);
        this.resultEventEmitter = createEvent(this, "result", 7);
    }
    componentWillLoad() {
        this.result = {
            data: undefined,
            errors: [],
            loading: true,
            networkStatus: undefined,
            stale: undefined
        };
        this.startSubscription();
    }
    onPropsChange() {
        this.stopSubscription();
        this.startSubscription();
    }
    componentDidUnload() {
        this.stopSubscription();
    }
    startSubscription() {
        if (this.client) {
            this._subscription = this.client.subscribe(Object.assign({ query: this.subscription, variables: this.variables }, this.options)).subscribe(result => {
                this.result = result;
                this.resultEventEmitter.emit(this.result);
            });
            this.readyEventEmitter.emit(this.result);
        }
        else {
            throw new Error('You should wrap your parent component with apollo-provider custom element or ApolloProvider functional component');
        }
    }
    stopSubscription() {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    }
    render() {
        return this.renderer && this.renderer(this.result);
    }
    get el() { return getElement(this); }
    static get watchers() { return {
        "client": ["onPropsChange"],
        "subscription": ["onPropsChange"],
        "variables": ["onPropsChange"],
        "renderer": ["onPropsChange"],
        "options": ["onPropsChange"]
    }; }
};
ApolloProviderConsumer.injectProps(ApolloSubscriptionComponent, ['client']);

export { ApolloMutationComponent as apollo_mutation, ApolloProviderComponent as apollo_provider, ApolloQueryComponent as apollo_query, ApolloSubscriptionComponent as apollo_subscription };
