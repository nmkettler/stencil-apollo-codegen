"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const isValidPath = require("is-valid-path");
const isGlob = require("is-glob");
const valid_url_1 = require("valid-url");
const load_from_url_1 = require("./load-from-url");
const path_1 = require("path");
const load_from_json_file_1 = require("./load-from-json-file");
const load_from_gql_file_1 = require("./load-from-gql-file");
const load_from_code_file_1 = require("./load-from-code-file");
const debugLog_1 = require("../utils/debugLog");
const fix_windows_path_1 = require("../utils/fix-windows-path");
const GQL_EXTENSIONS = ['.gql', '.graphql', '.graphqls'];
const CODE_FILE_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx'];
function filterFiles(files) {
    return files.filter(file => !file.endsWith('.d.ts') && !file.endsWith('.spec.ts') && !file.endsWith('.spec.js') && !file.endsWith('.test.ts') && !file.endsWith('.test.js'));
}
exports.filterKind = (content, filterKinds) => {
    if (content && filterKinds && filterKinds.length > 0) {
        if (content.definitions.length > 0) {
            const invalidDefinitions = [];
            const validDefinitions = [];
            for (const definitionNode of content.definitions) {
                if (filterKinds.includes(definitionNode.kind)) {
                    invalidDefinitions.push(definitionNode);
                }
                else {
                    validDefinitions.push(definitionNode);
                }
            }
            if (invalidDefinitions.length > 0) {
                invalidDefinitions.forEach(d => {
                    debugLog_1.debugLog(`Filtered document of kind ${d.kind} due to filter policy (${filterKinds.join(', ')})`);
                });
            }
            return {
                kind: graphql_1.Kind.DOCUMENT,
                definitions: validDefinitions,
            };
        }
    }
    return content;
};
async function loadTypedefs(pointToSchema, options = {}, filterKinds = [], cwd = process.cwd()) {
    const typesPaths = asArray(pointToSchema);
    const found$ = [];
    let found = [];
    const foundGlobs = [];
    for (const typesPath of typesPaths) {
        if (isSchemaString(typesPath)) {
            found$.push(Promise.resolve().then(async () => {
                let content = graphql_1.parse(typesPath);
                content = exports.filterKind(content, filterKinds);
                if (content && content.definitions && content.definitions.length > 0) {
                    found.push({
                        filePath: typesPath,
                        content
                    });
                }
            }));
        }
        else if (!valid_url_1.isUri(typesPath)) {
            const fixedPath = fix_windows_path_1.fixWindowsPath(typesPath);
            if (isValidPath(fixedPath)) {
                const relevantFiles = filterFiles(asArray(fixedPath));
                for (const filePath of relevantFiles) {
                    found$.push(Promise.resolve().then(async () => {
                        let content = await loadSingleFile(filePath, {
                            skipGraphQLImport: options.skipGraphQLImport,
                            noRequire: options.noRequire,
                            tagPluck: options.tagPluck || {}
                        }, cwd);
                        content = exports.filterKind(content, filterKinds);
                        if (content && content.definitions && content.definitions.length > 0) {
                            found.push({
                                filePath,
                                content
                            });
                        }
                    }));
                }
            }
            else if (isGlob(fixedPath)) {
                foundGlobs.push(fixedPath);
            }
        }
        else if (valid_url_1.isUri(typesPath)) {
            found$.push(Promise.resolve().then(async () => {
                let content = await load_from_url_1.loadFromUrl(typesPath, options);
                content = exports.filterKind(content, filterKinds);
                if (content && content.definitions && content.definitions.length > 0) {
                    found.push({
                        filePath: typesPath,
                        content,
                    });
                }
            }));
        }
    }
    if (foundGlobs.length > 0) {
        if (options.ignore) {
            const ignoreList = asArray(options.ignore).map(g => `!(${g})`).map(p => fix_windows_path_1.fixWindowsPath(p));
            if (ignoreList.length > 0) {
                foundGlobs.push(...ignoreList);
            }
        }
        const globby = eval(`require('globby')`);
        for await (let path of globby.stream(foundGlobs, { cwd, absolute: true })) {
            const filePath = path.toString('utf8');
            found$.push(Promise.resolve().then(async () => {
                let content = await loadSingleFile(filePath, { skipGraphQLImport: options.skipGraphQLImport, noRequire: options.noRequire, tagPluck: options.tagPluck || {} }, cwd);
                content = exports.filterKind(content, filterKinds);
                if (content && content.definitions && content.definitions.length > 0) {
                    found.push({
                        filePath,
                        content,
                    });
                }
            }));
        }
    }
    await Promise.all(found$);
    found = found.sort((left, right) => left.filePath.localeCompare(right.filePath));
    if (found.length === 0) {
        throw new Error(`Unable to find any GraphQL type definitions for the following pointers: ${typesPaths.join(', ')}`);
    }
    return found;
}
exports.loadTypedefs = loadTypedefs;
async function loadSingleFile(filePath, options = {}, cwd = process.cwd()) {
    const extension = path_1.extname(filePath).toLowerCase();
    const fullPath = fix_windows_path_1.fixWindowsPath(path_1.isAbsolute(filePath) ? filePath : path_1.resolve(cwd, filePath));
    try {
        if (extension === '.json') {
            return await load_from_json_file_1.loadFromJsonFile(fullPath);
        }
        else if (GQL_EXTENSIONS.includes(extension)) {
            return await load_from_gql_file_1.loadFromGqlFile(fullPath, options.skipGraphQLImport);
        }
        else if (CODE_FILE_EXTENSIONS.includes(extension)) {
            return await load_from_code_file_1.loadFromCodeFile(fullPath, options);
        }
    }
    catch (e) {
        debugLog_1.debugLog(`Failed to find any GraphQL type definitions in: ${filePath} - ${e.message}`);
        throw e;
    }
    return null;
}
exports.loadSingleFile = loadSingleFile;
function isSchemaString(str) {
    // XXX: is-valid-path or is-glob treat SDL as a valid path
    // (`scalar Date` for example)
    // this why checking the extension is fast enough
    // and prevent from parsing the string in order to find out
    // if the string is a SDL
    if (/\.[a-z0-9]+$/i.test(str)) {
        return false;
    }
    try {
        graphql_1.parse(str);
        return true;
    }
    catch (e) {
        return false;
    }
}
function asArray(str) {
    if (Array.isArray(str)) {
        return str;
    }
    return [str];
}
//# sourceMappingURL=load-typedefs.js.map