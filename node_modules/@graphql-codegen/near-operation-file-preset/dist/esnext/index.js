import { isUsingTypes } from '@graphql-codegen/plugin-helpers';
import { BaseVisitor, buildScalars, getPossibleTypes } from '@graphql-codegen/visitor-plugin-common';
import * as addPlugin from '@graphql-codegen/add';
import { join, resolve } from 'path';
import { Kind } from 'graphql';
import { appendExtensionToFilePath, defineFilepathSubfolder, extractExternalFragmentsInUse, resolveRelativeImport } from './utils';
export const preset = {
    buildGeneratesSection: options => {
        const baseVisitor = new BaseVisitor(options.config, {
            scalars: buildScalars(options.schemaAst, options.config.scalars),
        });
        const getAllFragmentSubTypes = (possbileTypes, name, suffix) => {
            if (possbileTypes.length === 0) {
                return [];
            }
            else if (possbileTypes.length === 1) {
                return [
                    baseVisitor.convertName(name, {
                        useTypesPrefix: true,
                        suffix: suffix,
                    }),
                ];
            }
            else {
                return possbileTypes.map(typeName => baseVisitor.convertName(name, {
                    useTypesPrefix: true,
                    suffix: `_${typeName}_${suffix}`,
                }));
            }
        };
        if (!options.presetConfig.baseTypesPath) {
            throw new Error(`Preset "near-operation-file" requires you to specify "baseTypesPath" configuration and point it to your base types file (generated by "typescript" plugin)!`);
        }
        const baseDir = options.presetConfig.cwd || process.cwd();
        const extension = options.presetConfig.extension || '.generated.ts';
        const folder = options.presetConfig.folder || '';
        const importTypesNamespace = options.presetConfig.importTypesNamespace || 'Types';
        const pluginMap = {
            ...options.pluginMap,
            add: addPlugin,
        };
        const duplicateFragmentNames = [];
        const fragmentNameToFile = options.documents.reduce((prev, documentRecord) => {
            const fragments = documentRecord.content.definitions.filter(d => d.kind === Kind.FRAGMENT_DEFINITION);
            if (fragments.length > 0) {
                for (const fragment of fragments) {
                    const schemaType = options.schemaAst.getType(fragment.typeCondition.name.value);
                    const possibleTypes = getPossibleTypes(options.schemaAst, schemaType);
                    const fragmentSuffix = options.config.dedupeOperationSuffix && fragment.name.value.toLowerCase().endsWith('fragment') ? '' : 'Fragment';
                    const filePath = appendExtensionToFilePath(documentRecord.filePath, extension);
                    const importsNames = getAllFragmentSubTypes(possibleTypes.map(t => t.name), fragment.name.value, fragmentSuffix);
                    if (prev[fragment.name.value]) {
                        duplicateFragmentNames.push(fragment.name.value);
                    }
                    prev[fragment.name.value] = { filePath, importsNames, onType: fragment.typeCondition.name.value, node: fragment };
                }
            }
            return prev;
        }, {});
        if (duplicateFragmentNames.length) {
            throw new Error(`Multiple fragments with the name(s) "${duplicateFragmentNames.join(', ')}" were found.`);
        }
        const absTypesPath = resolve(baseDir, join(options.baseOutputDir, options.presetConfig.baseTypesPath));
        return options.documents
            .map(documentFile => {
            const newFilePath = defineFilepathSubfolder(documentFile.filePath, folder);
            const generatedFilePath = appendExtensionToFilePath(newFilePath, extension);
            const absGeneratedFilePath = resolve(baseDir, generatedFilePath);
            const relativeImportPath = resolveRelativeImport(absGeneratedFilePath, absTypesPath);
            const fragmentsInUse = extractExternalFragmentsInUse(documentFile.content, fragmentNameToFile);
            const plugins = [...options.plugins];
            const config = {
                ...options.config,
                // This is set here in order to make sure the fragment spreads sub types
                // are exported from operations file
                exportFragmentSpreadSubTypes: true,
                namespacedImportName: importTypesNamespace,
                externalFragments: [],
            };
            for (const fragmentName of Object.keys(fragmentsInUse)) {
                const level = fragmentsInUse[fragmentName];
                const fragmentDetails = fragmentNameToFile[fragmentName];
                if (fragmentDetails) {
                    const fragmentGeneratedFilePath = defineFilepathSubfolder(fragmentDetails.filePath, folder);
                    const absFragmentFilePath = resolve(baseDir, fragmentGeneratedFilePath);
                    const fragmentImportPath = resolveRelativeImport(absGeneratedFilePath, absFragmentFilePath);
                    if (!options.config.globalNamespace && level === 0) {
                        plugins.unshift({
                            add: `import { ${fragmentDetails.importsNames.join(', ')} } from '${fragmentImportPath}';`,
                        });
                    }
                    config.externalFragments.push({
                        level,
                        isExternal: true,
                        importFrom: fragmentImportPath,
                        name: fragmentName,
                        onType: fragmentDetails.onType,
                        node: fragmentDetails.node,
                    });
                }
            }
            if (isUsingTypes(documentFile.content, config.externalFragments.map(m => m.name), options.schemaAst)) {
                plugins.unshift({ add: `import * as ${importTypesNamespace} from '${relativeImportPath}';\n` });
            }
            return {
                filename: generatedFilePath,
                plugins,
                pluginMap,
                config,
                schema: options.schema,
                schemaAst: options.schemaAst,
                documents: [documentFile],
                skipDocumentsValidation: true,
            };
        })
            .filter(f => f);
    },
};
export default preset;
//# sourceMappingURL=index.js.map