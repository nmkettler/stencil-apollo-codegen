"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cosmiconfig = require("cosmiconfig");
const path_1 = require("path");
const core_1 = require("@graphql-codegen/core");
const commander_1 = require("commander");
function generateSearchPlaces(moduleName) {
    const extensions = ['json', 'yaml', 'yml', 'js', 'config.js'];
    // gives codegen.json...
    const regular = extensions.map(ext => `${moduleName}.${ext}`);
    // gives .codegenrc.json... but no .codegenrc.config.js
    const dot = extensions.filter(ext => ext !== 'config.js').map(ext => `.${moduleName}rc.${ext}`);
    return regular.concat(dot);
}
function customLoader(ext) {
    function loader(filepath, content) {
        if (typeof process !== 'undefined' && 'env' in process) {
            content = content.replace(/\$\{(.*)\}/g, (str, variable, index) => {
                let varName = variable;
                let defaultValue = '';
                if (variable.includes(':')) {
                    const spl = variable.split(':');
                    varName = spl.shift();
                    defaultValue = spl.join(':');
                }
                return process.env[varName] || defaultValue;
            });
        }
        if (ext === 'json') {
            return cosmiconfig.loadJson(filepath, content);
        }
        if (ext === 'yaml') {
            return cosmiconfig.loadYaml(filepath, content);
        }
        if (ext === 'js') {
            return cosmiconfig.loadJs(filepath, content);
        }
    }
    return {
        sync: loader,
        async: loader,
    };
}
async function loadConfig(configFilePath) {
    const moduleName = 'codegen';
    const cosmi = cosmiconfig(moduleName, {
        searchPlaces: generateSearchPlaces(moduleName),
        loaders: {
            '.json': customLoader('json'),
            '.yaml': customLoader('yaml'),
            '.yml': customLoader('yaml'),
            '.js': customLoader('js'),
            noExt: customLoader('yaml'),
        },
    });
    const result = await (configFilePath ? cosmi.load(configFilePath) : cosmi.search(process.cwd()));
    if (!result) {
        if (configFilePath) {
            throw new core_1.DetailedError(`Config ${configFilePath} does not exist`, `
        Config ${configFilePath} does not exist.
  
          $ graphql-codegen --config ${configFilePath}
  
        Please make sure the --config points to a correct file.
      `);
        }
        throw new core_1.DetailedError(`Unable to find Codegen config file!`, `
        Please make sure that you have a configuration file under the current directory! 
      `);
    }
    if (result.isEmpty) {
        throw new core_1.DetailedError(`Found Codegen config file but it was empty!`, `
        Please make sure that you have a valid configuration file under the current directory!
      `);
    }
    return {
        filepath: result.filepath,
        config: result.config,
    };
}
exports.loadConfig = loadConfig;
function getCustomConfigPath(cliFlags) {
    const configFile = cliFlags.config;
    return configFile ? path_1.resolve(process.cwd(), configFile) : null;
}
function collect(val, memo) {
    memo.push(val);
    return memo;
}
function parseArgv(argv = process.argv) {
    return new commander_1.Command()
        .usage('graphql-codegen [options]')
        .allowUnknownOption(true)
        .option('-c, --config <path>', 'Path to GraphQL codegen YAML config file, defaults to "codegen.yml" on the current directory')
        .option('-w, --watch', 'Watch for changes and execute generation automatically')
        .option('-s, --silent', 'A flag to not print errors in case they occur')
        .option('-r, --require [value]', 'Loads specific require.extensions before running the codegen and reading the configuration', collect, [])
        .option('-o, --overwrite', 'Overwrites existing files')
        .parse(argv);
}
exports.parseArgv = parseArgv;
async function createConfig(cliFlags = parseArgv(process.argv)) {
    const customConfigPath = getCustomConfigPath(cliFlags);
    const configSearchResult = await loadConfig(customConfigPath);
    if (cliFlags.require && cliFlags.require.length > 0) {
        for (const mod of cliFlags.require) {
            await Promise.resolve().then(() => require(mod));
        }
    }
    const parsedConfigFile = configSearchResult.config;
    parsedConfigFile.configFilePath = configSearchResult.filepath;
    if (cliFlags.watch === true) {
        parsedConfigFile.watch = cliFlags.watch;
    }
    if (cliFlags.overwrite === true) {
        parsedConfigFile.overwrite = cliFlags.overwrite;
    }
    if (cliFlags.silent === true) {
        parsedConfigFile.silent = cliFlags.silent;
    }
    return parsedConfigFile;
}
exports.createConfig = createConfig;
//# sourceMappingURL=config.js.map